# -*- rd -*-

= README.ja

$Id$

== 作者

Kouhei Sutou <kou@cozmixng.org>

== ライセンス

GPL or BSD License

== メーリングリスト

((<COZMIXNG RWiki - 連絡先
|URL:http://www.cozmixng.org/~rwiki/?cmd=view;name=%CF%A2%CD%ED%C0%E8>))
を御覧下さい．

== なにこれ？

tsm（Tuple Space in (on??) Scheme）は
((<dsm|URL:http://www.cozmixng.org/~rwiki/?cmd=view;name=dsm>))
を用いたタプルスペースライブラリです．インタフェースは
((<Rinda|URL:http://www2a.biglobe.ne.jp/~seki/ruby/rinda.html>))
を参考にしています．

以下のような機能があります．

  * タプルに有効期限を設定する．
  * タプルのマッチにはutil.match互換のパターンを使う．

以下のような機能はありません（実装する気はあります）．

  * イベント（takeとかwrite）発生時にコールバックを起動する．
  * （数値やリストや文字列など）基本的な型以外のオブジェクト
    をタプルを通じて共有する．
  * move（クライアントにタプルを返すのが成功したらタプルスペー
    スからタプルを削除する安全なtake）

== 依存ライブラリ

  * ((<dsm|URL:http://www.cozmixng.org/~rwiki/?cmd=view;name=dsm>))
  * ((<marshal|URL:http://www.cozmixng.org/~rwiki/?cmd=view;name=marshal>))

== 入手方法

#((<URL:http://www.cozmixng.org/~kou/download/tsm.tar.gz>))

  % svn co http://www.cozmixng.org/repos/gauche/tsm/trunk tsm

== インストール

  # gosh install/install.scm

== 構造

tsmでは2つ以上のタスク（処理の単位．スレッドを用いていなけれ
ば1プロセスは1タスクになります（いいよね？）が，スレッドを用
いていれば1プロセスにつき複数のタスクを持つことができます）
を用いてタプルスペースを利用します．ひとつはタプルスペースを
提供するタスクで，それ以外はタプルスペースを利用するタスク
（クライアント）です（もちろん，タプルスペースを利用するタス
クが複数のタプルスペースを利用することもできますが，ここでは
割愛します）．


  +--------------+     +----------------+     +--------------+
  | クライアント | <-> | タプルスペース | <-> | クライアント |
  +--------------+     +----------------+     +--------------+
                         ^            ^
      +--------------+   |            |  +--------------+
      | クライアント | <-+    ...     +->| クライアント |
      +--------------+                   +--------------+



タプルスペースはタプルを保管する空間を提供します．この空間は
タプルスペースを提供するタスクが終了すると消滅します．空間が
消滅すると空間内のタプルは破棄されます．

== 利用法

クライアントはタプルスペースに対して，タプルを書く／取ってく
るという操作を行います．tsmでは，それぞれ
(({tuple-space-write}))／(({tuple-space-take}))という手続き
になります．

例えば，クライアント1（Aとします）がクライアント2（Bとします）
に(({(1 2 3)}))というリストを渡すという問題を考えます．タプ
ルスペースを用いると，この問題は以下のように解決できます．

  (1) タプルスペースを起動する．
  (1) Aがタプルスペースに(({(1 2 3)}))というタプルを書き込む．
  (1) Bがタプルスペースから(({(1 2 3)}))というタプルを取り出
      す．

タプルスペースにはA，B以外が扱うタプルも存在するので，タプル
には，タプルを識別するためのタグを付ける事が多いでしょう．例
えば，今回は，Aが書き込むタプルには(({to-B}))というタグを付
けることにします．

今回の解決法では3つのタスクが存在します．それぞれ，タプルス
ペース，A，Bです．それぞれのコードを以下に示します．

=== タプルスペース 

タプルスペースのコードは以下のようになります．

  (use tsm.tuple-space)

  (define (main args)
    (let ((tuple-space (make-tuple-space "dsmp://:2929")))
      (tuple-space-start! tuple-space)
      (tuple-space-join! tuple-space)))

(({make-tuple-space}))でタプルスペースを作成し，
(({tuple-space-start!}))で起動しているだけです．
(({tuple-space-join!}))はタプルスペースが終了するのを待ちま
す．

タプルスペース自体は「場」を提供するだけで，ロジックを組み込
むことはないので，多くのタプルスペースのコードは以上のように
なるでしょう．

=== A

Aのコードは以下のようになります．

  (use tsm.proxy)

  (define (main args)
    (let ((tuple-space (tuple-space-connect "dsmp://localhost:2929")))
      (tuple-space-write tuple-space '(to-B (1 2 3)))))

(({tuple-space-connect}))でタプルスペースに接続し，
(({tuple-space-write}))でタプルスペースに(({(to-B (1 2
3))}))というタプルを書き込んでいます．リストの最初の要素であ
る(({to-B}))がタグになります．

=== B

Bのコードは以下のようになります．

  (use tsm.proxy)

  (define (main args)
    (let ((tuple-space (tuple-space-connect "dsmp://localhost:2929")))
      (print (cdr (tuple-space-take tuple-space
                                    '(('to-B ((? number?) ...))))))))

(({tuple-space-take}))には

== 例1

あるタスク（writerとします）はタプルを書き込みまくり，別のタ
スク（readerとします）はタプルを取り出しまくってみましょう．

以下の3つのファイルを作成します．

  * tuple-space.scm
  * writer.scm
  * reader.scm

=== tuple-space.scm

  #!/usr/bin/env gosh

  (use tsm.tuple-space)

  (define *port* 2929)

  (define (main args)
    (let ((tuple-space (make-tuple-space #`"dsmp://:,|*port*|")))
      (tuple-space-start! tuple-space)
      (tuple-space-join! tuple-space)))

=== writer.scm

  #!/usr/bin/env gosh

  (use srfi-1)
  (use tsm.proxy)

  (define *server* "localhost")
  (define *port* 2929)

  (define (main args)
    (let ((tuple-space (tuple-space-connect #`"dsmp://,|*server*|:,|*port*|")))
      (for-each (lambda (i)
                  (tuple-space-write tuple-space i '(1 0))
                  (tuple-space-write tuple-space (list i)))
                (iota 10))))

=== reader.scm

  #!/usr/bin/env gosh

  (use tsm.proxy)

  (define *server* "localhost")
  (define *port* 2929)

  (define (main args)
    (let ((tuple-space (tuple-space-connect #`"dsmp://,|*server*|:,|*port*|")))
      (do ()
          (#f)
        (print (tuple-space-take tuple-space '(_))))))

=== 起動する．

最初にtuple-space.scmを起動しておけば，writer.scmと
reader.scmはどのような順序で起動しても構いません．writer.scm
とreader.scmを複数起動しても構いません．

すべて起動すると，writer.scmが書き込んだタプルをreader.scmが
ひたすら吐き出します．
